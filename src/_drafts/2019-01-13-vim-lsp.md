---
layout: post
title: Autocompletion with Vim in 2019.
tags: dotfiles
---

A common observation can be made with newcomers and Vim; plethoras of plugins
are installed to transform the minimal editor into something vaguely resembling
an IDE. Often it's not long until the topic of "autocompletion" comes up, and
how Vim's apparent lack thereof spawns posts titled "I can't get YouCompleteMe
to work"...

If that sounds uncanny, I speak from a similar experience. Like others gone
before me, I too tried the lot—YouCompleteMe, Eclim, Tern, Jedi... if this is
starting to sound pessimistic you can probably tell where this is heading.  **In
2018 I removed the lot**, committing instead to learn Vim's "vanilla"
autocompletion. If you take one thing from this, please study `:help
ins-completion`; `<C-x><C-l>` still provides what I need 9 times out of 10.

## But then came Language Servers.

The development of _VS Code_ introduced the Language Server Protocol (LSP): an
interface between text-editors and servers that provide autocomplete
capabilities (et.  al). Such LSP compliant servers (Language Servers) are
different to traditional autocomplete engines in that they are vendor agnostic;
they run as stand-alone daemons on a host machine as opposed to being bundled
into text-editors' source code.

In practice, this means you can run a single Language Server and have many
(LSP-compliant) text-editors use it. The inverse means you can install _one_
plug in and profit for as many Language Servers you care to install:

![vim lsp](./src/assets/vim-lsp.png "vim lsp")

## Installing Language Servers—tedium.

Hopefully this is starting to sound feasible—at least conceptually. In my
opinion, the least intuitive part of Language Servers is _installing_ them. Take
for instance, the example config for autozimu/LanguageClient-neovim:

```
let g:LanguageClient_serverCommands = {
    \ 'rust': ['~/.cargo/bin/rustup', 'run', 'stable', 'rls'],
    \ 'javascript': ['/usr/local/bin/javascript-typescript-stdio'],
    \ 'javascript.jsx': ['tcp://127.0.0.1:2089'],
    \ 'python': ['/usr/local/bin/pyls'],
    \ }
```

This configuration suggests you can:

A. Point to a Language Server binary installed on your host, or
B. Connect to an existing Language Server via TCP.

Option A is probably the quickest way to get started; you could `$ npm install
-g javascript-typescript-langserver`, and point LanguageClient-neovim to the
`javascript-typescript-stdio` binary. Job done for Javascript. Want LSP
capabilities for Python too? `$ pip install python-language-server` and point to
`pyls`. Alright... but imagine doing this for multiple languages? And what if
you have multiple machines—say one at home and one at work? What if they install
the Language Servers into subtly different locations, breaking your shared
dotfiles? You might appreciate this tedium kept me from using LSP in Vim.

## Language Server over TCP.

Option B (connect to Language Servers via TCP) solved my issues, and allowed me
to fully integrate LSP into my workflow—something I'm "precious" about. The
difference is we shift responsibility for the Language Server's life-cycle to
the host machine, as opposed to the LanguageClient-neovim plugin. Put another
way, when the host guarantees a Language Server is listening on a specific port,
it provides a contract that decouples Vim (et. al) from machine/plugin specific
idiosyncrasies.
